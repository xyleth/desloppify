{
  "command": "review",
  "mode": "holistic",
  "language": "python",
  "dimensions": [
    "cross_module_architecture",
    "initialization_coupling",
    "convention_outlier",
    "error_consistency",
    "abstraction_fitness",
    "dependency_health",
    "test_strategy",
    "api_surface_coherence",
    "authorization_consistency",
    "ai_generated_debt",
    "incomplete_migration",
    "package_organization",
    "high_level_elegance",
    "mid_level_elegance",
    "low_level_elegance"
  ],
  "dimension_prompts": {
    "cross_module_architecture": {
      "description": "Cross-module architecture (codebase scope): dependency direction, cycles, hubs, and boundary integrity.",
      "look_for": [
        "Layer/dependency direction violations repeated across multiple modules",
        "Cycles or hub modules that create large blast radius for common changes",
        "Cross-module coordination through shared mutable state or import-time side effects",
        "Cross-package/plugin duplication that indicates a missing shared boundary",
        "Only file when the pattern is structural and visible across 2+ module relationships"
      ],
      "skip": [
        "Intentional facades/re-exports with clear API purpose",
        "Framework-required patterns (Django settings, plugin registries)",
        "Package naming/placement tidy-ups without boundary harm (belongs to package_organization)",
        "Local readability/craft issues (belongs to low_level_elegance or per-file review)"
      ]
    },
    "initialization_coupling": {
      "description": "Boot-order dependencies, import-time side effects, global singletons",
      "look_for": [
        "Module-level code that depends on another module having been imported first",
        "Import-time side effects: DB connections, file I/O, network calls at module scope",
        "Global singletons where creation order matters across modules",
        "Environment variable reads at import time (fragile in testing)",
        "Circular init dependencies hidden behind conditional or lazy imports"
      ],
      "skip": [
        "Standard library initialization (logging.basicConfig)",
        "Framework bootstrap (app.configure, server.listen)"
      ]
    },
    "convention_outlier": {
      "description": "Naming convention drift, inconsistent file organization, style islands",
      "look_for": [
        "Naming convention drift: snake_case functions in a camelCase codebase or vice versa",
        "Inconsistent file organization: some dirs use index files, others don't",
        "Mixed export patterns across sibling modules (named vs default, class vs function)",
        "Style islands: one directory uses a completely different pattern than the rest",
        "Inconsistent directory structure: some features flat, others deeply nested",
        "Sibling modules in the same directory following different behavioral protocols (e.g. most call a shared function but one doesn't)",
        "Inconsistent plugin organization: sibling plugins structured differently (e.g. one uses phases.py, another puts phases in __init__.py)",
        "Large __init__.py re-export surfaces that obscure internal module structure"
      ],
      "skip": [
        "Intentional variation for different module types (config vs logic)",
        "Third-party code or generated files following their own conventions"
      ]
    },
    "error_consistency": {
      "description": "Mixed error strategies, inconsistent error types, lost context",
      "look_for": [
        "Mixed error strategies across modules: some throw, some return null, some use Result types",
        "Error context lost at module boundaries: catch-and-rethrow without wrapping",
        "Inconsistent error types: custom error classes in some modules, bare strings in others",
        "Silent error swallowing: catches that log but don't propagate or recover",
        "Missing error handling on I/O boundaries (file, network, parse operations)"
      ],
      "skip": [
        "Intentional error boundaries at top-level handlers",
        "Different strategies for different layers (e.g. Result in core, throw in CLI)"
      ]
    },
    "abstraction_fitness": {
      "description": "Python codebase abstraction fitness: abstractions should reduce repeated complexity across modules, not hide flow.",
      "look_for": [
        "Cross-module wrapper chains where calls hop through helper layers before reaching real logic",
        "Project-wide reliance on generic helper modules instead of bounded domain packages",
        "Protocol/interface declarations with only one implementation across the codebase",
        "Repeated use of broad context/config dictionaries in place of explicit interfaces"
      ],
      "skip": [
        "Intentional package facades used to stabilize public import paths",
        "Framework-required adapter seams around Django/FastAPI/SQLAlchemy integration points",
        "Migration shims with active callers and clear sunset plan"
      ]
    },
    "dependency_health": {
      "description": "Unused deps, version conflicts, multiple libs for same purpose, heavy deps",
      "look_for": [
        "Multiple libraries for the same purpose (e.g. moment + dayjs, axios + fetch wrapper)",
        "Heavy dependencies pulled in for light use (e.g. lodash for one function)",
        "Circular dependency cycles visible in the import graph",
        "Unused dependencies in package.json/requirements.txt",
        "Version conflicts or pinning issues visible in lock files"
      ],
      "skip": [
        "Dev dependencies (test, build, lint tools)",
        "Peer dependencies required by frameworks"
      ]
    },
    "test_strategy": {
      "description": "Untested critical paths, coupling, snapshot overuse, fragility patterns",
      "look_for": [
        "Critical paths with zero test coverage (high-importer files, core business logic)",
        "Test-production coupling: tests that break when implementation details change",
        "Snapshot test overuse: >50% of tests are snapshot-based",
        "Missing integration tests: unit tests exist but no cross-module verification",
        "Test fragility: tests that depend on timing, ordering, or external state"
      ],
      "skip": [
        "Low-value files intentionally untested (types, constants, index files)",
        "Generated code that shouldn't have custom tests"
      ]
    },
    "api_surface_coherence": {
      "description": "Inconsistent API shapes, mixed sync/async, overloaded interfaces",
      "look_for": [
        "Inconsistent API shapes: similar functions with different parameter ordering or naming",
        "Mixed sync/async in the same module's public API",
        "Overloaded interfaces: one function doing too many things based on argument types",
        "Missing error contracts: no documentation or types indicating what can fail",
        "Public functions with >5 parameters (API boundary may be wrong)"
      ],
      "skip": [
        "Internal/private APIs where flexibility is acceptable",
        "Framework-imposed patterns (React hooks must follow rules of hooks)"
      ]
    },
    "authorization_consistency": {
      "description": "RLS gaps, auth middleware inconsistency, permission granularity mismatch",
      "look_for": [
        "Route handlers with auth decorators/middleware on some siblings but not others",
        "RLS enabled on some tables but not siblings in the same domain",
        "Permission strings as magic literals instead of shared constants",
        "Mixed trust boundaries: some endpoints trust user input, siblings validate",
        "Service role / admin bypass without audit logging or access control"
      ],
      "skip": [
        "Public routes explicitly documented as unauthenticated (health checks, login, webhooks)",
        "Internal service-to-service calls behind network-level auth",
        "Dev/test endpoints behind feature flags or environment checks"
      ]
    },
    "ai_generated_debt": {
      "description": "LLM-hallmark patterns: restating comments, defensive overengineering, boilerplate",
      "look_for": [
        "Restating comments that echo the code without adding insight (// increment counter above i++)",
        "Nosy debug logging: entry/exit logs on every function, full object dumps to console",
        "Defensive overengineering: null checks on non-nullable typed values, try-catch around pure expressions",
        "Docstring bloat: multi-line docstrings on trivial 2-line functions",
        "Pass-through wrapper functions with no added logic (just forward args to another function)",
        "Generic names in domain code: handleData, processItem, doOperation where domain terms exist",
        "Identical boilerplate error handling copied verbatim across multiple files"
      ],
      "skip": [
        "Comments explaining WHY (business rules, non-obvious constraints, external dependencies)",
        "Defensive checks at genuine API boundaries (user input, network, file I/O)",
        "Generated code (protobuf, GraphQL codegen, ORM migrations)",
        "Wrapper functions that add auth, logging, metrics, or caching"
      ]
    },
    "incomplete_migration": {
      "description": "Old+new API coexistence, deprecated-but-called symbols, stale migration shims",
      "look_for": [
        "Old and new API patterns coexisting: class+functional components, axios+fetch, moment+dayjs",
        "Deprecated symbols still called by active code (@deprecated, DEPRECATED markers)",
        "Compatibility shims that no caller actually needs anymore",
        "Mixed JS/TS files for the same module (incomplete TypeScript migration)",
        "Stale migration TODOs: TODO/FIXME referencing 'migrate', 'legacy', 'old api', 'remove after'",
        "Class components alongside functional in the same feature directory"
      ],
      "skip": [
        "Active, intentional migrations with tracked progress",
        "Backward-compatibility for external consumers (published APIs, libraries)",
        "Gradual rollouts behind feature flags with clear ownership"
      ]
    },
    "package_organization": {
      "description": "Directory structure, file placement, package boundaries, architectural layering",
      "look_for": [
        "Straggler files: root-level files with low fan-in (<5 importers) that share a theme with other root files \u2014 should be grouped into a subpackage (e.g. 3 visualization files loose at root \u2192 output/ subpackage)",
        "Import affinity mismatch: files whose imports come >60% from one sibling directory \u2014 the file likely belongs in that directory, not its current location",
        "Layer violations in the coupling matrix: downstream directories importing from upstream (e.g. a utility module importing from a command module), or bidirectional coupling between directories that should have a clear dependency direction",
        "Flat directories with >10 files where files serve different concerns \u2014 suggest splitting by theme (the flat_dirs detector catches count, but not whether the flatness is justified)",
        "Inconsistent depth: sibling directories at the same level with wildly different nesting depth, suggesting uneven structural investment",
        "Directory names that don't match contents (e.g. utils/ full of domain logic, helpers/ with core business rules)"
      ],
      "skip": [
        "Root-level files that ARE genuinely core \u2014 high fan-in (\u22655 importers), imported across multiple subdirectories (cli.py, state.py, utils.py, config.py)",
        "Small projects (<20 files) where flat structure is appropriate",
        "Framework-imposed directory layouts (src/, lib/, dist/, __pycache__/)",
        "Test directories mirroring production structure",
        "Single-purpose packages where flatness is intentional"
      ]
    },
    "high_level_elegance": {
      "description": "High-level elegance (codebase shape): coherent decomposition, clear ownership, domain-aligned structure.",
      "look_for": [
        "Top-level packages/directories map to domain capabilities rather than historical accidents",
        "Ownership and boundaries are clear enough that common feature work has predictable change paths",
        "A small set of architectural patterns is used consistently across major areas",
        "Subsystem decomposition localizes change and avoids broad, surprising edits",
        "Only file when the pattern appears across multiple directories/packages"
      ],
      "skip": [
        "Dependency direction/cycle/hub failures (belongs to cross_module_architecture)",
        "Module-to-module handoff mechanics (belongs to mid_level_elegance)",
        "Function/class implementation craft (belongs to low_level_elegance)",
        "Raw dependency package hygiene unless it directly harms decomposition legibility"
      ]
    },
    "mid_level_elegance": {
      "description": "Mid-level elegance (connective tissue): quality of handoffs across modules and layers.",
      "look_for": [
        "Layer choreography is consistent (for example request -> domain -> persistence)",
        "Boundary contracts are small, stable, and translated at clear seam points",
        "Cross-module error/state propagation follows predictable patterns",
        "Integration seams avoid glue-code entropy (ad-hoc mappers and boundary conditionals)",
        "Only file when seam friction appears across multiple boundary pairs"
      ],
      "skip": [
        "Codebase decomposition and package taxonomy (belongs to high_level_elegance)",
        "Policy-level dependency direction failures (belongs to cross_module_architecture)",
        "Pure local function/class craft with no seam pattern (belongs to low_level_elegance)",
        "Naming/style preferences that do not affect seams or integration quality"
      ]
    },
    "low_level_elegance": {
      "description": "Low-level elegance (aggregate craft): recurring quality of function/class internals across the codebase.",
      "look_for": [
        "Many modules show concise internals with clear invariants and straightforward control flow",
        "Helper extraction style is consistently balanced across areas",
        "Incidental complexity patterns (ceremony, defensive sprawl, opaque indirection) recur across many files",
        "Local state/effect handling is generally explicit and bounded across the codebase",
        "Only file when the pattern is recurrent; isolated nits belong to per-file review"
      ],
      "skip": [
        "Architecture/package-level design concerns (belongs to high_level_elegance)",
        "Cross-module seam choreography and contract shape (belongs to mid_level_elegance)",
        "Dependency topology/policy failures (belongs to cross_module_architecture)",
        "Single-file issues that do not recur at codebase scale"
      ]
    }
  },
  "lang_guidance": {
    "patterns": [
      "Check for `async def` functions that never `await` \u2014 they add overhead with no benefit",
      "Look for bare `except:` or `except Exception:` that swallow errors silently",
      "Verify `@lru_cache` isn't used on methods with mutable default args",
      "Flag `subprocess` calls without `timeout` parameter",
      "Check for mutable class-level variables (list/dict/set as class attributes)",
      "Verify `__all__` is defined when `from module import *` is used"
    ],
    "auth": [
      "Check `@login_required` consistency \u2014 sibling views in same module should all have it or none",
      "Flag `request.user` access in views without `@login_required` or equivalent auth decorator",
      "Look for unvalidated `request.data` / `request.POST` used directly in ORM queries",
      "Verify permission decorators match route sensitivity (admin views need `@staff_member_required`)"
    ],
    "naming": "Python uses snake_case for functions/variables, PascalCase for classes. Check for Java-style camelCase leaking in."
  },
  "holistic_context": {
    "architecture": {
      "god_modules": [],
      "top_imported": {}
    },
    "coupling": {},
    "conventions": {
      "naming_by_directory": {},
      "sibling_behavior": {}
    },
    "errors": {
      "strategy_by_directory": {}
    },
    "abstractions": {
      "util_files": [],
      "summary": {
        "wrapper_rate": 0.0,
        "total_wrappers": 0,
        "total_function_signatures": 2,
        "one_impl_interface_count": 0,
        "indirection_hotspot_count": 0,
        "wide_param_bag_count": 0
      },
      "sub_axes": {
        "abstraction_leverage": 100,
        "indirection_cost": 100,
        "interface_honesty": 100
      }
    },
    "dependencies": {},
    "testing": {
      "total_files": 1
    },
    "api_surface": {},
    "structure": {
      "directory_profiles": {}
    },
    "codebase_stats": {
      "total_files": 1,
      "total_loc": 9
    }
  },
  "review_context": {
    "naming_vocabulary": {
      "prefixes": {
        "add": 1
      },
      "total_names": 2
    },
    "error_conventions": {},
    "module_patterns": {},
    "import_graph_summary": {
      "top_imported": {}
    },
    "zone_distribution": {
      "test": 1
    },
    "existing_findings": {
      ".": [
        "subjective_review: No holistic codebase review on record \u2014 run `desloppify review --prepare`"
      ]
    },
    "codebase_stats": {
      "total_files": 1,
      "total_loc": 9,
      "avg_file_loc": 9
    },
    "sibling_conventions": {},
    "ai_debt_signals": {
      "file_signals": {},
      "codebase_avg_comment_ratio": 0.0
    }
  },
  "system_prompt": "You are reviewing a codebase holistically for cross-cutting quality issues that can only be seen by looking at the whole project.\n\nUnlike per-file review, you are evaluating PATTERNS ACROSS THE CODEBASE \u2014 architectural decisions, convention drift, systemic issues.\n\nRULES:\n1. Only emit findings for genuine codebase-wide patterns (not single-file issues).\n2. Every finding MUST include a `related_files` array with 2+ files as evidence.\n3. Every finding MUST include a concrete, actionable suggestion.\n4. Be specific: \"3 different error handling strategies across 4 modules\" NOT \"error handling could be more consistent.\"\n5. Calibrate confidence: high = any senior eng would agree, medium = most would agree, low = reasonable engineers might disagree.\n6. Prefer high-signal findings, but do NOT suppress recurring patterns; 2-10 holistic findings is normal when evidence supports them.\n7. For abstraction_fitness, explicitly inspect pass-through wrapper chains, one-implementation interfaces, and wide options/context bag APIs.\n8. Quick fixes vs planning: if a fix is simple (add a docstring, rename a symbol, add a missing import), include the exact change in your suggestion. For larger refactors, describe the approach and which files to modify.\n9. Score from evidence, not from a target. Do NOT anchor to 95 or any threshold when assigning assessments.\n10. If evidence is weak or mixed, score lower and explain uncertainty; optimistic scoring without evidence is considered gaming.\n\nCALIBRATION \u2014 use these examples to anchor your confidence scale:\n\nHIGH confidence (any senior engineer would agree):\n- \"utils.py imported by 23/30 modules \u2014 god module, split by domain\"\n- \"3 error handling strategies (throw, return null, Result) across service layer\"\n- \"@login_required on 8/10 route handlers, missing on /admin/export and /admin/bulk\"\n\nMEDIUM confidence (most engineers would agree):\n- \"Convention drift: commands/ uses snake_case, handlers/ uses camelCase\"\n- \"axios used in api/ but fetch used in hooks/ \u2014 consolidate to one HTTP client\"\n- \"5 TODO comments reference 'legacy migration' from 8+ months ago\"\n\nLOW confidence (reasonable engineers might disagree):\n- \"helpers.py has 15 functions \u2014 consider splitting (threshold is subjective)\"\n- \"Some modules use explicit re-exports, others rely on __init__.py barrel\"\n\nNON-FINDINGS (skip these):\n- Consistent patterns applied uniformly \u2014 even if imperfect, consistency matters more\n- Style preferences without measurable impact (import ordering, blank lines)\n- Intentional variation for different layers (e.g. Result in core, throw in CLI)\n\nOUTPUT FORMAT \u2014 JSON object with four keys:\n\n{\n  \"assessments\": {\n    \"<dimension_name>\": <score 0-100>,\n    ...\n  },\n  \"dimension_notes\": {\n    \"<dimension_name>\": {\n      \"evidence\": [\"specific cross-cutting observation\"],\n      \"impact_scope\": \"local|module|subsystem|codebase\",\n      \"fix_scope\": \"single_edit|multi_file_refactor|architectural_change\",\n      \"confidence\": \"high|medium|low\",\n      \"unreported_risk\": \"required when score >85\"\n    }\n  },\n  \"findings\": [{\n    \"dimension\": \"<one of the holistic dimensions>\",\n    \"identifier\": \"short_descriptive_id\",\n    \"summary\": \"One-line finding (< 120 chars)\",\n    \"related_files\": [\"path/to/file1.ts\", \"path/to/file2.ts\"],\n    \"evidence\": [\"specific cross-cutting observation\"],\n    \"suggestion\": \"concrete action: consolidate X, extract Y, standardize Z\",\n    \"reasoning\": \"why this matters at the codebase level\",\n    \"impact_scope\": \"local|module|subsystem|codebase\",\n    \"fix_scope\": \"single_edit|multi_file_refactor|architectural_change\",\n    \"confidence\": \"high|medium|low\"\n  }],\n  \"review_quality\": {\n    \"unreported_risks\": [\"risk summary for high scores\"]\n  }\n}\n\nASSESSMENTS: Score every holistic dimension you evaluated on a 0-100 scale. 100 = exemplary, 80 = good with minor issues, 60 = significant issues, 40 = poor, 20 = severely problematic. Assessments drive the codebase health score directly \u2014 each becomes a scoring dimension.\n\nFINDINGS: Specific cross-cutting issues to fix. Return [] in the findings array if the codebase has no cross-cutting issues worth flagging. Most codebases should have 2-10 holistic findings when multiple dimensions have concrete evidence. Findings are work items visible via `desloppify issues` \u2014 a state-backed work order that agents can pick up and fix independently. Your suggestions should be actionable enough to follow without further research.\n\nPython holistic focus: track recurring pass-through helper layers, single-implementation Protocols, and dict-heavy context seams across package boundaries.",
  "total_files": 1,
  "workflow": [
    "Read .desloppify/query.json for context, excerpts, and investigation batches",
    "For each batch: read the listed files, evaluate the batch's dimensions (batches are independent \u2014 parallelize)",
    "Cross-reference findings with the sibling_behavior and convention data",
    "For simple issues (missing import, wrong name): fix directly in code, then note as resolved",
    "For cross-cutting issues: write to findings.json (format described in system_prompt)",
    "Import: desloppify review --import findings.json",
    "Run `desloppify issues` to see the work queue, then fix each finding and resolve"
  ],
  "investigation_batches": [],
  "narrative": {
    "phase": "first_scan",
    "headline": "First scan complete. 1 open findings across 3 dimensions.",
    "dimensions": {
      "lowest_dimensions": [
        {
          "name": "Naming Quality",
          "strict": 0.0,
          "issues": 0,
          "impact": 0.0,
          "subjective": true,
          "impact_description": "re-review to improve"
        },
        {
          "name": "Error Consistency",
          "strict": 0.0,
          "issues": 0,
          "impact": 0.0,
          "subjective": true,
          "impact_description": "re-review to improve"
        },
        {
          "name": "Abstraction Fit",
          "strict": 0.0,
          "issues": 0,
          "impact": 0.0,
          "subjective": true,
          "impact_description": "re-review to improve"
        }
      ],
      "biggest_gap_dimensions": [],
      "stagnant_dimensions": []
    },
    "actions": [
      {
        "type": "manual_fix",
        "detector": "subjective_review",
        "count": 1,
        "description": "1 files need design review \u2014 run design review with dimension templates",
        "command": "desloppify fix review",
        "impact": 0.0,
        "dimension": "Test health",
        "priority": 1,
        "lane": "refactor"
      }
    ],
    "strategy": {
      "fixer_leverage": {
        "auto_fixable_count": 0,
        "total_count": 1,
        "coverage": 0.0,
        "impact_ratio": 0.0,
        "recommendation": "none"
      },
      "lanes": {
        "refactor": {
          "actions": [
            1
          ],
          "file_count": 1,
          "total_impact": 0.0,
          "automation": "manual",
          "run_first": false
        }
      },
      "can_parallelize": false,
      "hint": "Work through actions in priority order. Rescan after each fix to track progress."
    },
    "tools": {
      "fixers": [],
      "move": {
        "available": true,
        "relevant": false,
        "reason": null,
        "usage": "desloppify move <source> <dest> [--dry-run]"
      },
      "plan": {
        "command": "desloppify plan",
        "description": "Generate prioritized markdown cleanup plan"
      },
      "badge": {
        "generated": true,
        "in_readme": true,
        "path": "scorecard.png",
        "recommendation": null
      }
    },
    "debt": {
      "overall_gap": 0.0,
      "wontfix_count": 0,
      "worst_dimension": null,
      "worst_gap": 0.0,
      "trend": "stable"
    },
    "milestone": null,
    "reminders": [
      {
        "type": "zone_classification",
        "message": "1 of 1 files classified as non-production (1 test). Override with `desloppify zone set <file> production` if any are misclassified.",
        "command": "desloppify zone show"
      }
    ],
    "reminder_history": {
      "report_scores": 1,
      "zone_classification": 2
    }
  },
  "next_command": "desloppify review --import findings.json",
  "config": {
    "target_strict_score": 98,
    "review_max_age_days": 30,
    "holistic_max_age_days": 30,
    "generate_scorecard": true,
    "badge_path": "scorecard.png",
    "exclude": [],
    "ignore": [],
    "zone_overrides": {},
    "review_dimensions": [],
    "large_files_threshold": 0,
    "props_threshold": 0,
    "finding_noise_budget": 10,
    "finding_noise_global_budget": 0,
    "languages": {}
  }
}
